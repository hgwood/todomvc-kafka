- facts should be union of assertion and retraction
- how to retract an entity
  - keep map of entity to attribute list and generate retraction for each attribute
  - retraction with no attribute
- should not use facts ?
  - facts are the same as partial updates
    - no read before write, but complex building of current state (object merging)
    - cannot statically typed because of all the possible partial update combinations
  - alternative to facts is full updates
    - some actions like editTodo or completeTodo require to read the todo to get the other attribute and form a full update
    - current state is easy to build: just take the most recent message
    - easier to statically type
- completeAll and clearCompleted are macro-actions: they generate multiple actions
- completeAll and clearCompleted require reading existing data to be interpreted
- current implementation of Action is not scalable because needs all possible fields
  - Action could be enum with toFacts method ? Not coupling because only existing for the Action to Facts processor
- current tests use one broker by tests; could use one broker for the suite if tests passed new topics, new application id to code and used new consumer groups for each test
- don't forget error handling (put messages that raise errors into specific topics)
- ActionsToFacts could be tested without a streams : it's just a Action -> [Fact] function
- aggregation seem slow to test (FactsToDataTest.singleAssertion takes 40s to run) and I don't see how to test them outside of Streams
  - there seems to be quite a lot of timing issue with streams integration tests
  - SOLUTION: unit testing topologies!! https://github.com/apache/kafka/blob/0.11.0.0/streams/src/test/java/org/apache/kafka/test/ProcessorTopologyTestDriver.java
  - works well; some tests still need to be refactored
- action that generate multiple facts should have these facts emitted as part of a transaction
- how to emit only entities that are "complete" (all the facts received make complete transactions)
  - group facts by transaction id before grouping them by entity id
  - that thing does eliminate emitting at all
  - transactions as messages ?
    - can flat map into facts if necessary
    - transactions need to be in one partition per user
    - makes me think of blockchain : transactions in blocks, but here transactions are facts and blocks are transactions
- action validation
  - actions can be of 4 natures
    - malformed: missing or invalid fields, action is invalid in and of itself
    - invalid: not applicable to the current state
    - noop: would not modify the current state
    - ok: will be applied to the current state
